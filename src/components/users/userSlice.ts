import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { RootState } from '../../app/store';
import { fetchUserList, fetchAddUser, fetchDeleteUser } from './usersAPI';


export interface UserState {
  status: 'idle' | 'loading' | 'failed';
  userList: any;
}

const initialState: UserState = {
  status: 'idle',
  userList: [],
};


export const userListApi = createAsyncThunk(
  'users/fetchUserListApi',
  async () => {
    const response = await fetchUserList();
    const json = await response.json();
    // console.log('response - ', response)
    // console.log(json);
    return json;


  }
);


export const addUserApi = createAsyncThunk(
  'users/fetchAddUserApi',
  async (userObj: any) => {
    const response = await fetchAddUser(userObj);

    if (response.status === 201) {
      const json = await response.json();
      // console.log('response - ', response)
      // console.log(json);
      return json;
    }
    else {
      console.log('Ошибка при добавлении нового пользователя')
    }

  }
);

export const deleteUserApi = createAsyncThunk(
  'users/fetchDeleteUserApi',
  async (userId: number) => {
    const response = await fetchDeleteUser(userId);

    if (response.status === 200) {
      //const json = await response.json();
      // console.log('response - ', response)
      // console.log(json);
      return userId;
    }
    else {
      console.log('Ошибка при удалении пользователя')
    }
  }
);

localStorage.setItem("sortId", "down");
const sortLocalStorageFunc = (userArr: any, sortFlag?: boolean) => {

  let sortIdStorage = localStorage.getItem("sortId");
  if (sortFlag && sortIdStorage === "down") {
    localStorage.setItem("sortId", "up");
  } else if (sortFlag && sortIdStorage === "up") {
    localStorage.setItem("sortId", "down");
  }

  sortIdStorage = localStorage.getItem("sortId");
  if (sortIdStorage && sortIdStorage === "up") {
    return [...userArr].sort((a: any, b: any) => a.id - b.id);
  } else if (sortIdStorage && sortIdStorage === "down") {
    return [...userArr].sort((a: any, b: any) => b.id - a.id);
  }
  else {
    return [];
  }
}

export const userSlice = createSlice({
  name: 'users',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    sortId: (state) => {
      state.userList = sortLocalStorageFunc([...state.userList], true) || [];
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(userListApi.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(userListApi.fulfilled, (state, action) => {
        state.status = 'idle';

        let userListSort = [...state.userList]
        let arrUserId = [...userListSort].map((item: any) => item.id) || [];

        [...action.payload].forEach((item: any) => {
          if (arrUserId.indexOf(item.id) === -1) {
            userListSort.push(item)
          }

        })

        state.userList = sortLocalStorageFunc([...userListSort]) || [];
      })
      .addCase(userListApi.rejected, (state) => {
        state.status = 'failed';
      })

      .addCase(addUserApi.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(addUserApi.fulfilled, (state, action) => {
        state.status = 'idle';


        // При добавлении нового пользователя сервис jsonplaceholder всегда возвращает id === 11, 
        // поэтому ниже добавлен код чтобы при добавлении нового пользователя ему присваивался id предыдущего user увеличенного на 1.
        let arrUserId = [...state.userList].map((item: any) => item.id) || [];
        const maxUserId = Math.max.apply(null, arrUserId)
        if (state.userList.length > 0 && action.payload.id <= maxUserId) {
          let userListSort = [...state.userList, ...[{ ...action.payload, id: maxUserId + 1 }]];

          state.userList = sortLocalStorageFunc([...userListSort]) || [];

        }
        else {
          let userListSort = [...state.userList, ...[action.payload]];
          state.userList = sortLocalStorageFunc([...userListSort]) || [];
        }
      })
      .addCase(addUserApi.rejected, (state) => {
        state.status = 'failed';
      })


      .addCase(deleteUserApi.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(deleteUserApi.fulfilled, (state, action) => {
        state.status = 'idle';

        let userListSort = [...state.userList].filter((item: any) => item.id !== action.payload)
        
        state.userList = sortLocalStorageFunc([...userListSort]);

        // console.log('state - ', state)
        // console.log('action - ', action)

      })
      .addCase(deleteUserApi.rejected, (state) => {
        state.status = 'failed';
      })

  },
});



export const { sortId } = userSlice.actions;


// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file.
export const selectUserList = (state: RootState) => state.users.userList;
export const selectStatus = (state: RootState) => state.users.status;

export default userSlice.reducer;
